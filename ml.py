# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1HIaWB-PM7rTZrVkSBmhkw1E-Faed6akM
"""
import streamlit as st
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

# Importaciones de Machine Learning (Scikit-learn)
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.tree import DecisionTreeRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.svm import SVR
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

# --- Funciones de Cálculo de Métricas ---

def calculate_metrics(y_true, y_pred, subset_name):
    """Calcula y retorna las métricas de rendimiento del modelo."""
    metrics = {
        'Subconjunto': subset_name,
        'R2': r2_score(y_true, y_pred),
        'MAE': mean_absolute_error(y_true, y_pred),
        'RMSE': np.sqrt(mean_squared_error(y_true, y_pred)),
        'Bias': np.mean(y_pred - y_true) # Sesgo medio
    }
    return metrics

# --- Estructura Principal de la Aplicación Streamlit ---

st.set_page_config(
    page_title="Análisis de Regresión Interactivo",
    layout="wide",
    initial_sidebar_state="expanded"
)

st.title("Aplicación Interactiva de Modelos de Regresión (Python/Streamlit)")
st.markdown("---")

# --- 1. Carga de Datos ---
with st.sidebar:
    st.header("1. Carga de Datos")
    uploaded_file = st.file_uploader(
        "Cargar archivo CSV (Asegúrese que los datos sean numéricos)",
        type=['csv']
    )

df = None
if uploaded_file is not None:
    df = None
    success_message = None
    
    # Lista de combinaciones (separador_columna, separador_decimal) a intentar
    formats = [
        (',', '.'),  # 1. Por defecto (US/UK): Coma (,) separador, Punto (.) decimal
        (';', ','),  # 2. LATAM/Europeo: Punto y coma (;) separador, Coma (,) decimal
        (',', ','),  # 3. Alternativa: Coma (,) separador, Coma (,) decimal
        (';', '.')   # 4. Alternativa: Punto y coma (;) separador, Punto (.) decimal
    ]

    for sep, dec in formats:
        try:
            # Intentar leer el archivo con la combinación de formato actual
            uploaded_file.seek(0)
            df_temp = pd.read_csv(uploaded_file, sep=sep, decimal=dec)
            
            # Verificar si se leyó más de una columna (indicador de éxito de 'sep')
            if df_temp.shape[1] > 1:
                df = df_temp
                success_message = f"CSV cargado con delimitador de columna '{sep}' y decimal '{dec}'."
                break # Éxito en la lectura inicial, salimos del bucle
        except Exception:
            continue # Intentar el siguiente formato
            
    if df is None:
        st.error("Error: No se pudo leer el archivo con los formatos comunes (',' o ';' como separador; '.' o ',' como decimal). Revise el formato de su CSV.")
        st.stop()
    
    # Si la lectura fue exitosa (df is not None)
    st.success(success_message)
        
    if df is not None:
        try:
            # Convertir a numérico y manejar valores no válidos
            for col in df.columns:
                # Intentar convertir las columnas a tipos numéricos (float).
                # Ya que definimos 'decimal' en read_csv, esto debería funcionar.
                df[col] = pd.to_numeric(df[col], errors='coerce') 
            
            # Eliminar filas con cualquier valor no numérico restante (NaN)
            original_rows = df.shape[0]
            df = df.dropna()
            
            if df.shape[0] == 0:
                st.error("El archivo no contiene filas de datos numéricos válidos después de la limpieza. Puede que haya caracteres no numéricos en sus datos o solo tenía encabezados.")
                df = None
                st.stop()
                
            if df.shape[0] < original_rows:
                 st.warning(f"Se eliminaron {original_rows - df.shape[0]} filas con datos no numéricos.")

            st.success(f"Datos cargados y limpiados: {df.shape[0]} filas, {df.shape[1]} columnas.")

        except Exception as e:
            st.error(f"Error al procesar los datos numéricos. Asegúrese de que todas las columnas seleccionadas contienen solo números. Detalles: {e}")
            df = None

# Solo continuar si los datos se han cargado correctamente
if df is not None and not df.empty:
    
    # Obtener nombres de columnas
    column_names = df.columns.tolist()

    # --- 2. Selección de Variables X (Features) y Y (Target) ---
    st.sidebar.header("2. Selección de Variables")
    
    # Selección de variables X (múltiple)
    selected_features = st.sidebar.multiselect(
        "Seleccionar Variables Independientes (X):",
        column_names,
        default=column_names[:-1] # Sugiere todas excepto la última por defecto
    )

    # Selección de variable Y (única)
    selected_target = st.sidebar.selectbox(
        "Seleccionar Variable Dependiente (Y):",
        column_names,
        index=len(column_names) - 1 # Sugiere la última columna por defecto
    )

    # Validación de selección
    if not selected_features or selected_target is None:
        st.warning("Por favor, selecciona al menos una variable X y una variable Y.")
        st.stop()
        
    if selected_target in selected_features:
        st.error("La variable Y no puede estar en el conjunto de variables X.")
        st.stop()

    # --- 3. División de Datos y Preprocesamiento ---
    
    # Separación de X y Y
    X = df[selected_features].values
    y = df[selected_target].values
    
    # División en entrenamiento y validación (80/20)
    X_train, X_test, y_train, y_test = train_test_split(
        X, y, test_size=0.2, random_state=42
    )
    
    st.sidebar.markdown("---")

    # --- 4. Selección del Modelo ---
    st.sidebar.header("3. Configuración del Modelo")

    model_options = {
        "Regresión Lineal (Simple/Múltiple)": LinearRegression,
        "Árbol de Decisión (Regresor)": DecisionTreeRegressor,
        "Random Forest (Regresor)": RandomForestRegressor,
        "Máquinas de Soporte Vectorial (SVR)": SVR
    }
    
    model_name = st.sidebar.selectbox(
        "Seleccionar Modelo de Regresión:",
        list(model_options.keys())
    )
    
    # --- Hiperparámetros (Opcional, para demostrar interactividad) ---
    # Solo mostrar si se selecciona un modelo con hiperparámetros relevantes
    if model_name == "Random Forest (Regresor)":
        n_estimators = st.sidebar.slider("Número de estimadores (árboles):", 10, 200, 100, 10)
        max_depth = st.sidebar.slider("Profundidad máxima:", 2, 32, 10)
    else:
        n_estimators = 100
        max_depth = 10


    # Botón de Entrenamiento
    if st.sidebar.button("4. ENTRENAR MODELO"):
        
        # --- 5. Entrenamiento del Modelo ---
        
        try:
            st.info(f"Entrenando el modelo: **{model_name}**...")
            
            # Inicializar el modelo seleccionado
            model_class = model_options[model_name]
            
            if model_name == "Random Forest (Regresor)":
                 model = model_class(n_estimators=n_estimators, max_depth=max_depth, random_state=42)
            else:
                 # SVR necesita que y sea de forma (n_samples, )
                 if model_name == "Máquinas de Soporte Vectorial (SVR)":
                     model = model_class()
                     # Escalar características (necesario para SVR, aunque no se haga en otros modelos aquí)
                     # Para simplificar, asumimos que los datos ya están en una escala similar por la limpieza inicial.
                 else:
                     model = model_class()


            # Entrenar el modelo
            model.fit(X_train, y_train)
            st.success(f"¡Modelo de **{model_name}** entrenado con éxito!")

            # --- 6. Predicciones ---
            y_train_pred = model.predict(X_train)
            y_test_pred = model.predict(X_test)

            # --- 7. Métricas de Rendimiento ---
            st.header("5. Métricas de Rendimiento")

            # Calcular métricas para Entrenamiento y Validación
            metrics_train = calculate_metrics(y_train, y_train_pred, "Entrenamiento")
            metrics_test = calculate_metrics(y_test, y_test_pred, "Validación")
            
            # Crear un DataFrame para mostrar las métricas de forma tabular
            metrics_df = pd.DataFrame([metrics_train, metrics_test]).set_index('Subconjunto')
            st.table(metrics_df.style.format({
                'R2': '{:.4f}', 
                'MAE': '{:.4f}', 
                'RMSE': '{:.4f}', 
                'Bias': '{:.4f}'
            }))

            # --- 8. Gráficos de Dispersión (Real vs. Predicho) ---
            st.header("6. Gráficos de Predicción (Real vs. Simulada)")
            col1, col2 = st.columns(2)

            # Función para generar el gráfico
            def plot_scatter(y_true, y_pred, title, ax):
                """Genera el gráfico de dispersión (Actual vs Predicho)"""
                ax.scatter(y_true, y_pred, color='#3B82F6', alpha=0.6, label='Predicciones')
                
                # Línea de predicción perfecta (y=x)
                min_val = min(y_true.min(), y_pred.min())
                max_val = max(y_true.max(), y_pred.max())
                ax.plot([min_val, max_val], [min_val, max_val], 
                        color='#EF4444', linestyle='--', linewidth=2, label='Predicción Perfecta')

                ax.set_title(title)
                ax.set_xlabel(f"Valor Real de {selected_target}")
                ax.set_ylabel(f"Valor Predicho por el Modelo")
                ax.grid(True, linestyle=':', alpha=0.7)
                ax.legend()
                ax.set_aspect('equal', adjustable='box')


            # Gráfico de Entrenamiento
            with col1:
                st.subheader("Conjunto de Entrenamiento")
                fig_train, ax_train = plt.subplots(figsize=(6, 6))
                plot_scatter(y_train, y_train_pred, f"Entrenamiento: R2 = {metrics_train['R2']:.4f}", ax_train)
                st.pyplot(fig_train)

            # Gráfico de Validación
            with col2:
                st.subheader("Conjunto de Validación")
                fig_test, ax_test = plt.subplots(figsize=(6, 6))
                plot_scatter(y_test, y_test_pred, f"Validación: R2 = {metrics_test['R2']:.4f}", ax_test)
                st.pyplot(fig_test)
                
            plt.close('all') # Cerrar figuras para evitar problemas de memoria

        except Exception as e:
            st.error(f"Error durante el entrenamiento o la predicción. Esto puede ser causado por datos no escalables o problemas internos del modelo. Detalles: {e}")

else:
    # Mensaje inicial si no se ha cargado el archivo
    st.info("Por favor, carga un archivo CSV en la barra lateral izquierda para comenzar el análisis.")
    st.markdown("---")
    st.markdown("Esta aplicación permite seleccionar variables (X, Y), elegir un modelo de regresión y evaluar su rendimiento mediante métricas y gráficos de dispersión.")

